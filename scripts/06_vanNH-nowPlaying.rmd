```{r, echo=FALSE}
library(xtable)
library(plyr)

# when compiled via the control script, game identifier will have been
# read from command line and pre-stored in the environment
# for interactive use and development, set the game here
if(!exists("game")) { # default to first game of season, my development game
  game <- "2014-04-12_vanNH-at-pdxST"
  }

## parse the game identifier
tmp <- strsplit(game, split = "_")[[1]]
game_date <- tmp[1]
tmp <- strsplit(tmp[2], split = "-")[[1]]
away_team <- tmp[1]
home_team <- tmp[3]
```

# `r away_team` at `r home_team` `r game_date`

```{r, echo=FALSE, results="hide"}
build_roster_path <- function(team) {
  file.path("..", "rosters", paste0("2014_", team, "-roster.tsv"))}
away_roster_file <- build_roster_path(away_team)
home_roster_file <- build_roster_path(home_team)
game_file        <- file.path("..", "games", game, "cleanGoogleExtract",
                              paste0(game, "_gameplay-clean.tsv"))

sDat <- read.delim(game_file)
away_roster <- read.delim(away_roster_file, stringsAsFactors = FALSE)
home_roster <- read.delim(home_roster_file, stringsAsFactors = FALSE)

## until I decide otherwise, make sure player numbers are character
## replace NAs with ''
jFun <- function(x) {
  x <- as.character(x)
  x[is.na(x)] <- ""
  return(x)
  }
sDat <- transform(sDat, oNum = jFun(oNum), dNum = jFun(dNum))

## keep only D's, goals, and assists
ddd <- with(sDat, oCode == 'D' | dCode == 'D' |  # defensed
              oCode == 'FB' | dCode == 'FB' |    # foot block
              oCode == 'HB' | dCode == 'HB')     # hand block
ddd <- which(ddd)
ggg <- with(sDat, oCode == 'G' | dCode == 'G' |  # goal
              oCode == 'LG' | dCode == 'LG')     # long goal >40 yds
ggg <- which(ggg)
aaa <- ggg - 1
keep_me <- sort(c(ddd, ggg, aaa))
sDat <- sDat[keep_me, ]
# add formal check that G + LG = A for oCode and dCode
#table(sDat$oCode)

## deduce the score
sDat$goal <- grepl('G', with(sDat, paste(oCode, dCode)))
jFun <- function(x) {x[is.na(x)] <- FALSE; x}
jLevels <- levels(sDat$dTeam)
sDat$teamOne <- cumsum(jFun(with(sDat, goal & scTeam == jLevels[1])))
sDat$teamTwo <- cumsum(jFun(with(sDat, goal & scTeam == jLevels[2])))
sDat <- rename(sDat, c("teamOne" = jLevels[1], "teamTwo" = jLevels[2]))

## last year, I tracked the period too ... would need to get from point_info
# sDat$period <- c(TRUE, sDat$period[-nrow(sDat)])
# sDat$period <- cumsum(sDat$period)

## get the team associated with the players making the D, A, or G
sDat$assist <- grepl('A', with(sDat, paste(oCode, dCode)))
tmp <- with(sDat, ifelse(goal | assist, scTeam, NA))
sDat$plTeam <- jLevels[tmp]

## some of the D's are getting assigned to the wrong team

sDat$D <- grepl('D', with(sDat, paste(oCode, dCode)))
tmp <- with(sDat, ifelse(D & oCode == '', dTeam, oTeam))
sDat$plTeam[sDat$D] <- jLevels[tmp[sDat$D]]
tmp <- with(sDat,
            ifelse(goal & (oCode == 'G' | oCode == 'LG'), dTeam, oTeam))
sDat$plTeam[sDat$D] <- jLevels[tmp[sDat$D]]
# with(sDat, table(oCode %in% c('D', 'A', 'G', 'LG'),
#                  dCode %in% c('D', 'A', 'G', 'LG')))
sDat$plNum <- with(sDat, ifelse(oCode %in% c('D', 'A', 'G', 'LG'), oNum, dNum))
sDat$lname <- I(with(sDat,
                     ifelse(plTeam == "vanNH",
                            vRoster$last[match(sDat$plNum, vRoster$number)],
                            oRoster$last[match(sDat$plNum, oRoster$number)])))

## deal with cases where we have no last name
## happens when we use a number that's not on the roster or when we don't
## capture the number and enter ? instead
foo <- is.na(sDat$lname)
sDat[foo, ]
sDat$lname[foo] <- paste0(sDat$plTeam[foo], "-unknown")

sDat$player <- factor(paste(sDat$plTeam, sDat$plNum, sep = "-"))

subset(sDat, select = c(point, oTeam, dTeam, oNum, oCode, dNum, dCode, plTeam, plNum, lname, player))

## tally events by player
# pDat <- ddply(sDat, .(player, lastName, team), function(z) {
#   goals <- sum(z$event == "G")
#   assists  <-  sum(z$event == "A")
#   Ds  <-  sum(z$event == "D")
#   c(points = goals + assists,
#     goals = goals, assists = assists, Ds = Ds)
#   })
# teamDat <- split(pDat, pDat$team)
# teamDat <- llply(teamDat, function(z) {
#   z <- z[order(z$points, decreasing = TRUE), ]
#   rownames(z) <- NULL
#   subset(z, select = -team)
# })

## prepare to say which period we're in or if game over
# if(sDat$eop[nrow(sDat)] == "eog") {
#   whereInGame <- "game is complete"
# } else {
#   whereInGame <- paste("period", sDat$period[nrow(sDat)])
# }

## this must be a remnant of something ad hoc I was doing?
#z <- subset(sDat, point == 34)

## prepare for a game scoring progression table
# gDat <- ddply(sDat, .(point),
#               function(z) {
#                 period <- z$period[nrow(z)]
#                 vanNH <- z$vanNH[nrow(z)]
#                 seaRM <- z$seaRM[nrow(z)]
#                 comment <- z$comment[nrow(z)]
#                 
#                 score <- z$event == "G"
#                 if(sum(score, na.rm = TRUE) == 0) {
#                   ## no score
#                   desc <- "- no score -"
#                   return(c(period = period, desc = desc,
#                            vanNH = vanNH, seaRM = seaRM,
#                            comment = comment))
#                 }
#                 scorer <- paste(z$player[z$event == "G"],
#                                 z$lastName[z$event == "G"])
#                 assist <- z$event == "A"
#                 assister <- paste(z$player[z$event == "A"],
#                                   z$lastName[z$event == "A"])
#                 if(length(assister) != 1) assister <- NA
#                 desc <- paste(assister, "to", scorer)
#                 return(c(period = period, desc = desc,
#                          vanNH = vanNH, seaRM = seaRM,
#                          comment = comment))
#                 })
# gDat <- gDat[rev(seq_len(nrow(gDat))), ]
```

#### last update `r date()`:
# Vancouver Nighthawks `r sDat$vanNH[nrow(sDat)]`
# Seattle Rainmakers `r sDat$seaRM[nrow(sDat)]`
## `r whereInGame`

Go to ...
  * [Scoring progression](#scoringProgression)
  * [Player stats for Vancouver Nighthawks](#vanNH)
  * [Player stats for Seattle Rainmakers](#seaRM)
  * [Raw data](#rawData)

Scoring progression<a id="scoringProgression"></a>:
```{r results='asis', echo=FALSE, eval = FALSE}
foo <- xtable(gDat)
print(foo, type='html', include.rownames = FALSE)
```

points = goals + assists  
tables sorted in decreasing order based on points  
stats are cumulative for this game

Player stats for Vancouver Nighthawks <a id="vanNH"></a>:
```{r results='asis', echo=FALSE, eval = FALSE}
if(!is.null(teamDat$V)) {
  foo <- xtable(teamDat$V)
  print(foo, type='html', include.rownames = FALSE)
  }
```

Player stats for Seattle Rainmakers <a id="seaRM"></a>:
```{r results='asis', echo=FALSE, eval = FALSE}
if(!is.null(teamDat$S)) {
  foo <- xtable(teamDat$S)
  print(foo, type='html', include.rownames = FALSE)
}
```

Raw data from which above tables are made <a id="rawData"></a>:
```{r results='asis', echo=FALSE, eval = FALSE}
foo <- xtable(sDat)
print(foo, type='html', include.rownames = FALSE)
```

```{r, echo=FALSE, results="hide", eval = FALSE}
## one off analysis
## looking for double happinesses
dhDat <- dlply(sDat, .(point),
               function(z) {
                 dGuys <- z$player[z$event == "D"]
                 scorer <- z$player[z$event == "G"]
                 if(length(scorer) > 0) {
                   if(scorer %in% dGuys) {
                     return(scorer)
                     }
                   }
                 }
               )
```
