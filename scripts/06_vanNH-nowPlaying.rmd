```{r, echo=FALSE}
library(xtable)
library(plyr)
library(yaml)

# when compiled via the control script, game identifier will have been
# read from command line and pre-stored in the environment
# for interactive use and development, set the game here
if(!exists("game")) {
  #game <- "2014-04-12_vanNH-at-pdxST"
  #game <- "2014-04-20_sfoDF-at-vanNH"
  game <- "2014-05-10_seaRM-at-vanNH"
  }

## parse the game identifier
tmp <- strsplit(game, split = "_")[[1]]
game_date <- tmp[1]
tmp <- strsplit(tmp[2], split = "-")[[1]]
away_team <- tmp[1]
home_team <- tmp[3]
jTeams <- sort(c(away_team, home_team))
```

# `r away_team` at `r home_team` `r game_date`

```{r, echo=FALSE, results="hide"}
build_roster_path <- function(team) {
  file.path("..", "rosters", paste0("2014_", team, "-roster.tsv"))}
away_roster_file <- build_roster_path(away_team)
home_roster_file <- build_roster_path(home_team)
read_roster <- function(roster_file) {
  x <- read.delim(roster_file, stringsAsFactors = FALSE)
  x[c('number', 'last')]
}
away_roster <- read_roster(away_roster_file)
home_roster <- read_roster(home_roster_file)

yaml_file <- file.path("..", "games", game, paste0(game, "_game-info.yaml"))
game_yaml <- yaml.load_file(yaml_file)

game_file <- file.path("..", "games", game, "04_cleanedGame",
                       paste0(game, "_gameplay-clean.tsv"))
sDat <- read.delim(game_file,
                   colClasses = list(oNum = 'character', oCode = 'character',
                                     dNum = 'character', dCode = 'character'))

point_file <- file.path("..", "games", game, "04_cleanedGame",
                       paste0(game, "_points-clean.tsv"))
point_info <- read.delim(point_file, stringsAsFactors = FALSE)
sDat$period <- point_info$Period[match(sDat$point, point_info$point)]
  
## for now, player numbers in game data should be character
## why? so we can use '?' for anonymous
## make sure that is true and replace NAs with ''
jFun <- function(x) {
  x <- as.character(x)
  x[is.na(x)] <- ""
  return(x)
  }
sDat <- transform(sDat, oNum = jFun(oNum), dNum = jFun(dNum))

## determine 'master' code for an event
## assumes only one of oCode and dCode is populated, which is dangerous FIX
# tmp <- with(sDat, data.frame(oCode, dCode))
# tmp[apply(tmp, 1, function(x) sum(x != '') > 1), ]
sDat$code <- with(sDat, ifelse(oCode != '', oCode, dCode))
## attribute the event to a team

## save a version of sDat to display as raw data
sDat_safe <- sDat

## keep only D's, goals, and assists
sDat <- subset(sDat, code %in% c('A', 'D', 'G', 'LG'))
# str(sDat)
# table(sDat$code)

## attribute the Ds, goals and assists to a team
## at some point I need to look into / take control of jTeams vis-a-vis levels
## of any teams factors
tmp <- with(sDat, ifelse(oCode == '', dTeam, oTeam))
sDat$plTeam <- jTeams[tmp]

## identify the specific player associated with event
sDat$plNum <- with(sDat, ifelse(oCode == '', dNum, oNum))

## deduce the score
sDat$goal <- grepl('G', sDat$code)
jFun <- function(x) {x[is.na(x)] <- FALSE; x}
sDat$teamOne <- cumsum(jFun(with(sDat, goal & scTeam == jTeams[1])))
sDat$teamTwo <- cumsum(jFun(with(sDat, goal & scTeam == jTeams[2])))
sDat <- rename(sDat, c("teamOne" = jTeams[1], "teamTwo" = jTeams[2]))

## tidy up
vars_to_keep <- c("period", "point", "oTeam", "dTeam", "scTeam", "code",
                  "plTeam", "plNum", jTeams)
sDat <- sDat[vars_to_keep]

## look up player's last name
sDat$lname <-
  I(with(sDat,
         ifelse(plTeam == away_team,
                away_roster$last[match(sDat$plNum, away_roster$number)],
                home_roster$last[match(sDat$plNum, home_roster$number)])))

## deal with cases where we have no last name
## happens when we use a number that's not on the roster or when we don't
## capture the number and enter ? instead
## this is fairly untested in 2014 :( 
tmp <- is.na(sDat$lname)
#sDat[tmp, ]
#sDat$lname[tmp] <- paste0(sDat$plTeam[tmp], "-?")
sDat$lname[tmp] <- "?name?"

sDat$player <-
  with(sDat,
       factor(paste(plTeam, plNum, lname, sep = "-")))

## DONE WITH EVENT LEVEL DATA!

## prepare text reporting game status
whereInGame <-
  switch(game_yaml$game_status,
         complete = "game is complete",
         upcoming = "game is upcoming -- any data here is fake and for set up purposes",
         paste("period", sDat$period[nrow(sDat)]))

## tally events by player
plDat <- ddply(sDat, ~ player + plTeam, function(z) {
  goals <- sum(z$code == "G" | z$code == "LG")
  assists <- sum(z$code == "A")
  Ds  <-  sum(z$code == "D")
  c(points = goals + assists,
    goals = goals, assists = assists, Ds = Ds)
  })
teamDat <- split(plDat, plDat$plTeam)
teamDat <- llply(teamDat, function(z) {
  z <- z[order(z$points, decreasing = TRUE), ]
  rownames(z) <- NULL
  subset(z, select = -plTeam)
})

## prepare game scoring progression table
gDat <- ddply(sDat, ~ point,
              function(z) {
                point <- z$point[1]
                period <- z$period[nrow(z)]
                away_score <- z[[away_team]][nrow(z)]
                home_score <- z[[home_team]][nrow(z)]
                #comment <- z$comment[nrow(z)]
                
                time_before_after <-
                  unlist(point_info[point_info$point == point,
                                    grep("Clock", names(point_info))])
                names(time_before_after) <- NULL
                point_duration <-
                  -1 * diff(laply(strsplit(time_before_after, split = ":"),
                                  function(x) {
                                    x <- as.numeric(x)
                                    x[1] * 60 + x[2]
                                    }))
                point_duration_text <-
                  sprintf("%02d:%02d", point_duration %/% 60, point_duration %% 60)

                score <- z$code == "G" | z$code == "LG"
                if(sum(score, na.rm = TRUE) == 0) {
                  ## no score
                  desc <- "- no score -"
                  ret_val <- c(period = period, desc = desc,
                               away_score = away_score,
                               home_score = home_score)
                  }
                scorer <- paste(z$player[z$code == "G" | z$code == "LG"],
                                z$lastName[z$code == "G" | z$code == "LG"])
                assist <- z$code == "A"
                assister <- paste(z$player[z$code == "A"],
                                  z$lastName[z$code == "A"])
                if(length(assister) != 1) assister <- NA
                desc <- paste(assister, "to", scorer)
                ret_val <- c(period = period, 
                             begin = time_before_after[1],
                             end = time_before_after[2],
                             pt_duration = point_duration_text,
                             desc = desc,
                             away_score = away_score,
                             home_score = home_score)
                names(ret_val)[grep("away", names(ret_val))] <- away_team
                names(ret_val)[grep("home", names(ret_val))] <- home_team
                return(ret_val)
                })
gDat <- gDat[rev(seq_len(nrow(gDat))), ]
```

#### last update `r date()`
# `r away_team` `r sDat[[away_team]][nrow(sDat)]`
# `r home_team` `r sDat[[home_team]][nrow(sDat)]`
## `r whereInGame`

Go to ...
  * [Scoring progression](#scoringProgression)
  * [Player stats for `r away_team`](#away)
  * [Player stats for `r home_team`](#home)
  * [Data on goals, assists, D's](#selectData)
  * [Full raw data](#rawData)

## Scoring progression<a id="scoringProgression"></a>:
```{r results='asis', echo=FALSE}
foo <- xtable(gDat)
print(foo, type='html', include.rownames = FALSE)
```

## Player stats for `r away_team` <a id="away"></a>:

points = goals + assists  
tables sorted in decreasing order based on points  
stats are cumulative for this game

```{r results='asis', echo=FALSE}
if(!is.null(teamDat[[away_team]])) {
  foo <- xtable(teamDat[[away_team]])
  print(foo, type='html', include.rownames = FALSE)
  }
```

## Player stats for `r home_team` <a id="home"></a>:

points = goals + assists  
tables sorted in decreasing order based on points  
stats are cumulative for this game

```{r results='asis', echo=FALSE}
if(!is.null(teamDat[[home_team]])) {
  foo <- xtable(teamDat[[home_team]])
  print(foo, type='html', include.rownames = FALSE)
  }
```

## Raw data on select events (goals, assists, D's)<a id="selectData"></a>:
```{r results='asis', echo=FALSE}
foo <- xtable(sDat)
print(foo, type='html', include.rownames = FALSE)
```

## Full raw data<a id="rawData"></a>:

__Note: just for display purposes.__ Raw data in more useful forms can be found in the [GitHub repository](https://github.com/jennybc/vanNH). Find the game you're interested in in the `games` subdirectory.

```{r results='asis', echo=FALSE}
foo <- xtable(sDat_safe)
print(foo, type='html', include.rownames = FALSE)
```


```{r, echo=FALSE, results="hide", eval = FALSE}
## one off analysis
## looking for double happinesses
dhDat <- dlply(sDat, .(point),
               function(z) {
                 dGuys <- z$player[z$event == "D"]
                 scorer <- z$player[z$event == "G"]
                 if(length(scorer) > 0) {
                   if(scorer %in% dGuys) {
                     return(scorer)
                     }
                   }
                 }
               )
```
