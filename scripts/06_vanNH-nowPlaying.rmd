```{r, echo = FALSE, message = FALSE}
library(xtable)
library(plyr)
library(yaml)

# when compiled via the control script, game identifier will have been
# read from command line and pre-stored in the environment
# for interactive use and development, set the game here
if(!exists("game")) {
  #game <- "2014-04-12_vanNH-at-pdxST"
  game <- "2014-04-20_sfoDF-at-vanNH"
  #game <- "2014-05-10_seaRM-at-vanNH"
  #game <- "2014-05-31_vanNH-at-seaRM"
  #game <- "2014-06-07_seaRM-at-vanNH"
  }

## parse the game identifier
tmp <- strsplit(game, split = "_")[[1]]
game_date <- tmp[1]
tmp <- strsplit(tmp[2], split = "-")[[1]]
away_team <- tmp[1]
home_team <- tmp[3]
jTeams <- sort(c(away_team, home_team))

## define some groups of codes used in multiple places
goal_codes <- c('G', 'LG')
assist_codes <- c('A', 'LA', 'PUA')
d_codes <- c('D', 'HB', 'FB')
keeper_codes <- c(goal_codes, assist_codes, d_codes)
```

# `r away_team` at `r home_team` `r game_date`

```{r, echo = FALSE, results = "hide", message = FALSE}
build_roster_path <- function(team) {
  file.path("..", "rosters", paste0("2014_", team, "-roster.tsv"))}
away_roster_file <- build_roster_path(away_team)
home_roster_file <- build_roster_path(home_team)
read_roster <- function(roster_file) {
  x <- read.delim(roster_file, stringsAsFactors = FALSE)
  x[c('number', 'last')]
}
away_roster <- read_roster(away_roster_file)
home_roster <- read_roster(home_roster_file)

yaml_file <- file.path("..", "games", game, paste0(game, "_game-info.yaml"))
game_yaml <- yaml.load_file(yaml_file)

game_file <- file.path("..", "games", game, "04_cleanedGame",
                       paste0(game, "_gameplay-clean.tsv"))
sDat <- read.delim(game_file,
                   colClasses = list(pullNum = 'character',
                                     pullCode = 'character',
                                     recvNum = 'character',
                                     recvCode = 'character'))

point_file <- file.path("..", "games", game, "04_cleanedGame",
                       paste0(game, "_points-clean.tsv"))
point_info <- read.delim(point_file, stringsAsFactors = FALSE)
sDat$period <- point_info$Period[match(sDat$point, point_info$point)]

## set factor levels uniformly for all relevant 'team' variables
jFun <- function(x, jLevels = jTeams) factor(x, levels = jLevels)
sDat <- transform(sDat, pullTeam = jFun(pullTeam), recvTeam = jFun(recvTeam),
                  scorTeam = jFun(scorTeam))
point_info <- transform(point_info, pullTeam = jFun(pullTeam),
                        scorTeam = jFun(scorTeam))

## determine 'master' code for an event
## assumes only one of pullCode and recvCode is populated
## TO DO: make sure my cleaning script guarantees this!
# tmp <- with(sDat, data.frame(oCode, dCode))
# tmp[apply(tmp, 1, function(x) sum(x != '') > 1), ]
sDat$code <- with(sDat, ifelse(recvCode != '', recvCode, pullCode))
## TO DO: attribute the event to a team

## save a version of sDat to display as raw data
sDat_safe <- sDat

## keep only D's, goals, and assists
## problem: I'm not awarding a D for interceptions right now
sDat <- subset(sDat, code %in% keeper_codes)
#str(sDat)
#table(sDat$code)

## get back at least a dummy row for every point; necessary if a point has no
## game play with a keeper code
sDat <- join(point_info[c('point', 'pullTeam')], sDat)
## NAs in recvTeam and period can and will be eliminated
sDat$period[is.na(sDat$period)] <- sDat$period[which(is.na(sDat$period)) - 1]
## function to get the "other" team
get_opponent <- function(x) {
  jLevels <- levels(x)
  x <- ifelse(unclass(x) == 1, 2, 1)
  return(factor(jLevels[x], levels = jLevels))
}
sDat$recvTeam <- get_opponent(sDat$pullTeam)

## replace NAs in various character variables with ''
jFun <- function(x) { x[is.na(x)] <- ''; return(x) }
fix_vars <- c('pullNum', 'pullCode', 'recvNum', 'recvCode', 'code')
sDat[fix_vars] <- colwise(jFun)(sDat[fix_vars])

## attribute the Ds, goals and assists to a team
## but remember some events could be null placeholders for non-scoring points
tmp <- with(sDat, ifelse(recvCode == '', pullTeam, recvTeam))
tmp[is.na(sDat$event)] <- NA
sDat$plTeam <- jTeams[tmp]

## identify the specific player associated with event
sDat$plNum <- with(sDat, ifelse(recvCode == '', pullNum, recvNum))
sDat$plNum[is.na(sDat$event)] <- NA

## deduce the score
sDat$goal <- grepl('G', sDat$code)
jFun <- function(x) {x[is.na(x)] <- FALSE; x}
sDat$teamOne <- cumsum(jFun(with(sDat, goal & scorTeam == jTeams[1])))
sDat$teamTwo <- cumsum(jFun(with(sDat, goal & scorTeam == jTeams[2])))
sDat <- rename(sDat, c("teamOne" = jTeams[1], "teamTwo" = jTeams[2]))

## tidy up
vars_to_keep <- c("period", "point", "recvTeam", "pullTeam", "scorTeam", "code",
                  "plTeam", "plNum", jTeams)
sDat <- sDat[vars_to_keep]

## look up player's last name
sDat$lname <-
  I(with(sDat,
         ifelse(plTeam == away_team,
                away_roster$last[match(as.numeric(sDat$plNum),
                                       away_roster$number)],
                home_roster$last[match(as.numeric(sDat$plNum),
                                       home_roster$number)])))

## deal with cases where we have no last name
## happens when we use a number that's not on the roster or when we don't
## capture the number and enter ? instead
tmp <- is.na(sDat$lname) & !is.na(sDat$plTeam)
#sDat[tmp, ]
sDat$lname[tmp] <- "?name?"

sDat$player <- with(sDat, factor(paste(plTeam, plNum, lname, sep = "-")))

## DONE WITH EVENT LEVEL DATA!

## prepare text reporting game status
whereInGame <-
  switch(game_yaml$game_status,
         complete = "game is complete",
         upcoming = "game is upcoming -- any data here is fake and for set up purposes",
         paste("period", sDat$period[nrow(sDat)]))

## tally events by player
plDat <- ddply(sDat, ~ player + plTeam, function(z) {
  goals <- sum(z$code %in% goal_codes)
  assists <- sum(z$code %in% assist_codes)
  Ds  <-  sum(z$code %in% d_codes)
  c(points = goals + assists,
    goals = goals, assists = assists, Ds = Ds)
  })
teamDat <- split(plDat, plDat$plTeam)
teamDat <- llply(teamDat, function(z) {
  z <- arrange(z, desc(points), desc(goals), desc(assists), desc(Ds))
  rownames(z) <- NULL
  subset(z, select = -plTeam)
})

## prepare game scoring progression table
gDat <- ddply(sDat, ~ point,
              function(z) {
                n <- nrow(z)
                point <- z$point[1]
                period <- z$period[1]
                away_score <- z[[away_team]][n]
                home_score <- z[[home_team]][n]
                #comment <- z$comment[nrow(z)]
                
                time_before_after <-
                  unlist(point_info[point_info$point == point,
                                    grep("Clock", names(point_info))])
                names(time_before_after) <- NULL
                point_duration <-
                  -1 * diff(laply(strsplit(time_before_after, split = ":"),
                                  function(x) {
                                    x <- as.numeric(x)
                                    x[1] * 60 + x[2]
                                    }))
                point_duration_text <-
                  sprintf("%02d:%02d",
                          point_duration %/% 60, point_duration %% 60)
                
                is_a_goal <- z$code %in% goal_codes
                if(is_a_goal[n]) {
                  scorer <- z$player[is_a_goal]
                  is_an_assist <- z$code %in% assist_codes
                  if(sum(is_an_assist) < 1) { 
                    assister <- NA ## must be a callahan, right?
                    } else if(sum(is_an_assist) == 1) {
                      assister <- z$player[is_an_assist]
                      } else {
                        assister <- "???"
                        message(paste("point", point,
                                      ": more than 1 assist found?!?\n"))
                        }                  
                  desc <- paste(assister, "to", scorer)
                  } else { ## time ran out with no goal
                    desc <- "- no goal -"
                    }
                ret_val <- c(period = period, 
                             begin = time_before_after[1],
                             end = time_before_after[2],
                             pt_duration = point_duration_text,
                             desc = desc,
                             away_score = away_score,
                             home_score = home_score)
                ret_val <-
                  rename(ret_val, c("away_score" = away_team,
                                    "home_score" = home_team))
                return(ret_val)
                })
gDat <- gDat[rev(seq_len(nrow(gDat))), ]
```

#### last update `r date()`
# `r away_team` `r sDat[[away_team]][nrow(sDat)]`
# `r home_team` `r sDat[[home_team]][nrow(sDat)]`
## `r whereInGame`

Go to ...
  * [Scoring progression](#scoringProgression)
  * [Player stats for `r away_team`](#away)
  * [Player stats for `r home_team`](#home)
  * [Data on goals, assists, D's](#selectData)
  * [Full raw data](#rawData)

## Scoring progression<a id="scoringProgression"></a>:
```{r results='asis', echo=FALSE}
foo <- xtable(gDat)
print(foo, type='html', include.rownames = FALSE)
```

## Player stats for `r away_team` <a id="away"></a>:

points = goals + assists  
tables sorted in decreasing order based on points (then goals, assists, Ds)  
Ds = total of plain ol' D's (D), hand blocks (HB), and foot blocks (FB)  
stats are cumulative for this game

```{r results='asis', echo=FALSE}
if(!is.null(teamDat[[away_team]])) {
  foo <- xtable(teamDat[[away_team]])
  print(foo, type='html', include.rownames = FALSE)
  }
```

## Player stats for `r home_team` <a id="home"></a>:

points = goals + assists  
tables sorted in decreasing order based on points (then goals, assists, Ds)  
Ds = total of plain ol' D's (D), hand blocks (HB), and foot blocks (FB)  
stats are cumulative for this game

```{r results='asis', echo=FALSE}
if(!is.null(teamDat[[home_team]])) {
  foo <- xtable(teamDat[[home_team]])
  print(foo, type='html', include.rownames = FALSE)
  }
```

## Raw data on select events (goals, assists, D's)<a id="selectData"></a>:
```{r results='asis', echo=FALSE}
foo <- xtable(sDat)
print(foo, type='html', include.rownames = FALSE)
```

## Full raw data<a id="rawData"></a>:

__Note: just for display purposes.__ Raw data in more useful forms can be found in the [GitHub repository](https://github.com/jennybc/vanNH). Find the game you're interested in in the `games` subdirectory.

```{r results='asis', echo=FALSE}
foo <- xtable(sDat_safe)
print(foo, type='html', include.rownames = FALSE)
```


```{r, echo=FALSE, results="hide", eval = FALSE}
## one off analysis
## looking for double happinesses
dhDat <- dlply(sDat, .(point),
               function(z) {
                 dGuys <- z$player[z$event == "D"]
                 scorer <- z$player[z$event == "G"]
                 if(length(scorer) > 0) {
                   if(scorer %in% dGuys) {
                     return(scorer)
                     }
                   }
                 }
               )
```
